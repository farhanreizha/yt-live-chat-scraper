<!DOCTYPE html>
<html>
  <head>
    <title>Live Chat Viewer</title>
    <!-- <script src="https://cdn.tailwindcss.com"></script> -->
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    />
    <style>
      body {
        font-size: 14px;
      }
      /* Custom CSS for animations and additional styling */
      .chat-message {
        animation: slideIn 0.3s ease-out;
      }

      @keyframes slideIn {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      /* Badge styling */
      .badge {
        display: inline-block;
        padding: 0.15rem 0.3rem;
        border-radius: 0.25rem;
        font-size: 0.7rem;
        font-weight: bold;
        line-height: 1;
        text-transform: uppercase;
      }

      .leaderboard {
        display: inline-block;
        padding: 0.15rem 0.3rem;
        border-radius: 0.25rem;
        font-size: 0.7rem;
        font-weight: bold;
        line-height: 1;
        text-transform: uppercase;
      }

      /* Membership styling - Superchat style */
      .membership-message {
        /* background: rgba(34, 197, 94, 0.2);
        border-left: 4px solid rgb(34, 197, 94); */
        padding-left: 0.5rem;
        padding-top: 0.25rem;
        padding-bottom: 0.25rem;
      }

      .membership-duration {
        font-size: 0.6rem;
        margin-left: 0.2rem;
        opacity: 0.9;
        font-weight: bold;
        color: inherit;
      }

      /* Custom scrollbar */
      .chat-container::-webkit-scrollbar {
        width: 6px;
      }

      .chat-container::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.1);
      }

      .chat-container::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.3);
        border-radius: 3px;
      }
    </style>
  </head>

  <body class="w-full h-screen overflow-hidden flex flex-col">
    <!-- Chat Messages Container -->
    <div class="chat-container flex-1 overflow-y-auto p-3 space-y-3">
      <!-- Sample Chat Messages -->
      <div
        class="chat-message bg-gray-800/80 rounded-lg p-3 text-white shadow-lg shadow-gray-800/50 hidden"
      >
        <div class="flex items-start space-x-2">
          <img
            src="https://i.pravatar.cc/40?img=1"
            alt="User"
            class="w-8 h-8 rounded-full hidden avatar"
          />
          <div class="message-container">
            <div class="flex items-center author">
              <span class="author-name font-semibold text-gray-100"></span>
              <span class="badge hidden space-x-1"></span>
              <span class="leaderboard ml-1"></span>
            </div>
            <p class="text-sm mt-1 message"></p>
          </div>
        </div>
      </div>
    </div>

    <script>
      const videoId = 'putrirp';
      const socket = new WebSocket(`ws://localhost:3000/live/${videoId}`);

      socket.onopen = () => {
        console.log('Connected to server');
      };

      socket.onmessage = (event) => {
        const messagesData = JSON.parse(event.data);
        const chatContainer = document.querySelector('.chat-container');

        // Pastikan elemen template ditemukan sebelum mencoba mengkloningnya
        const itemMessageTemplate = document.querySelector('.chat-message');

        if (!itemMessageTemplate) {
          console.error('Error: Template element with class .chat-message not found.');
          return; // Hentikan eksekusi jika template tidak ditemukan
        }

        messagesData.forEach((msg) => {
          console.log(msg);
          const newItemMessage = itemMessageTemplate.cloneNode(true); // Kloning template
          newItemMessage.classList.remove('hidden'); // Jadikan terlihat

          // Apply membership styling to entire message container if isMessageMembership is true
          if (msg.message && msg.message.isMessageMembership) {
            newItemMessage.classList.add('bg-green-500/30', 'border', 'border-green-500/50');
          }

          const authorName = newItemMessage.querySelector('.author-name');
          const message = newItemMessage.querySelector('.message');
          const badge = newItemMessage.querySelector('.badge');
          const avatar = newItemMessage.querySelector('.avatar');
          const leaderboard = newItemMessage.querySelector('.leaderboard');

          // Handle avatar from author.photo
          if (avatar && msg.author && msg.author.photo) {
            avatar.src = msg.author.photo.replace(/`/g, '').trim();
            // avatar.classList.remove('hidden');
          }

          // Handle badges from author.badges array - prioritize badges array over boolean flags
          const hasOwnerBadge = msg.author && msg.author.isOwner;

          // Check actual badges in the badges array instead of relying on boolean flags
          const moderatorBadge =
            msg.author &&
            msg.author.badges &&
            msg.author.badges.find((b) => b.type === 'moderator');
          const memberBadge =
            msg.author && msg.author.badges && msg.author.badges.find((b) => b.type === 'member');
          const verifiedBadge =
            msg.author && msg.author.badges && msg.author.badges.find((b) => b.type === 'verified');

          // Check if user has any badges to display
          const hasAnyBadge = msg.author && msg.author.badges && msg.author.badges.length > 0;

          // Show badges based on actual badges array content
          if (badge && hasAnyBadge) {
            const badgesToShow = [];

            // Always show moderator badge first if present in badges array
            if (moderatorBadge) {
              badgesToShow.push({ badge: moderatorBadge, type: 'moderator' });
            }

            // Show membership badge if present in badges array (can be combined with moderator)
            if (memberBadge) {
              badgesToShow.push({ badge: memberBadge, type: 'member' });
            }

            // Show verified badge if present in badges array (can be combined with moderator)
            if (verifiedBadge) {
              badgesToShow.push({ badge: verifiedBadge, type: 'verified' });
            }

            if (badgesToShow.length > 0) {
              // Clear existing badge content and create multiple badges
              badge.innerHTML = '';
              badgesToShow.forEach((badgeData, index) => {
                const badgeElement = document.createElement('span');

                if (badgeData.badge.url) {
                  const badgeUrl = badgeData.badge.url.replace(/`/g, '').trim();
                  badgeElement.innerHTML = `<img src="${badgeUrl}" alt="${badgeData.badge.text}" class="inline-block">`;
                  badgeElement.classList.add('p-0', 'bg-transparent');
                } else {
                  badgeElement.textContent = badgeData.badge.text.replace(/`/g, '').trim();
                  badgeElement.classList.remove('p-0', 'bg-transparent');
                }

                // Set styling based on badge type - match CSS styling
                if (badgeData.type === 'moderator') {
                  badgeElement.innerHTML = '<i class="fa-solid fa-wrench"></i>';
                  // badgeElement.classList.add('bg-blue-500', 'text-blue-500', 'py-0.5', 'px-1');
                  badgeElement.classList.add('text-blue-500');
                  // } else if (badgeData.type === 'member') {
                  // badgeElement.classList.add('bg-green-500', 'text-white', 'py-0.5', 'px-1');
                } else if (badgeData.type === 'verified') {
                  badgeElement.innerHTML = '<i class="fa-regular fa-circle-check"></i>';
                  // badgeElement.classList.add('bg-gray-600', 'text-white', 'py-0.5', 'px-1');
                }

                badge.appendChild(badgeElement);
              });

              badge.classList.remove('hidden');
            } else {
              badge.classList.add('hidden');
            }
          } else if (badge) {
            // Hide badge if no membership, verified, or moderator status
            badge.classList.add('hidden');
          }

          if (authorName) {
            // const name =
            //   msg.author && msg.author.name.includes('@')
            //     ? msg.author.name.split('@')[1]
            //     : msg.author.name;
            authorName.textContent = msg.author.name;
            // Remove all color classes
            authorName.classList.remove(
              'text-gray-100',
              'text-green-500',
              'text-blue-500',
              'text-yellow-500',
            );
            if (hasOwnerBadge) {
              authorName.classList.add('text-yellow-500');
            } else if (moderatorBadge) {
              authorName.classList.add('text-blue-500');
            } else if (memberBadge) {
              authorName.classList.add('text-green-500');
            }
          }
          // Handle leaderboard ranking
          if (leaderboard && msg.leaderboard) {
            leaderboard.textContent = msg.leaderboard.replace(/`/g, '').trim();
            leaderboard.classList.remove('hidden');
            leaderboard.classList.add('bg-purple-600', 'text-white', 'font-bold');
          } else if (leaderboard) {
            leaderboard.classList.add('hidden');
          }

          if (message) {
            let messageHtml = '';
            if (msg.message) {
              if (msg.message.text) {
                messageHtml = msg.message.text;
                if (msg.message.emojis && msg.message.emojis.length > 0) {
                  msg.message.emojis.forEach((emoji) => {
                    if (emoji.text && emoji.url) {
                      const text = emoji.text.replace(/`/g, '').trim();
                      const url = emoji.url.replace(/`/g, '').trim();
                      const escapedText = text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                      const regex = new RegExp(escapedText, 'g');
                      messageHtml = messageHtml.replace(
                        regex,
                        `<img src="${url}" alt="${text}" class="inline-block h-5 w-5 align-text-bottom">`,
                      );
                    }
                  });
                }
              }
            }
            message.innerHTML = messageHtml;

            // Apply membership styling and create membership badges
            if (msg.message && msg.message.isMessageMembership) {
              message.classList.add('membership-message');

              // Create membership status and tier badges
              const messageContainer = message.parentElement;
              if (messageContainer) {
                const membershipInfo = document.createElement('div');
                membershipInfo.className = 'flex items-center space-x-2 mt-1';

                if (msg.message.membershipStatus) {
                  const statusBadge = document.createElement('span');
                  statusBadge.textContent = msg.message.membershipStatus;
                  statusBadge.className =
                    'bg-purple-600 text-white text-xs px-2 py-1 rounded-full font-bold';
                  membershipInfo.appendChild(statusBadge);
                }

                if (msg.message.membershipTier) {
                  const tierBadge = document.createElement('span');
                  tierBadge.textContent = msg.message.membershipTier;
                  tierBadge.className =
                    'bg-green-600 text-white text-xs px-2 py-1 rounded-full font-bold';
                  membershipInfo.appendChild(tierBadge);
                }

                messageContainer.classList.add(
                  'border-l-4',
                  'border-solid',
                  'border-[rgb(34, 197, 94)]',
                  'bg-[rgba(34, 197, 94, 0.2)]',
                );

                messageContainer.appendChild(membershipInfo);
              }
            }
          }

          chatContainer.appendChild(newItemMessage); // Tambahkan elemen baru ke daftar obrolan
        });

        // Auto scroll to bottom when new messages arrive
        chatContainer.scrollTop = chatContainer.scrollHeight;
        // Limit to 50 messages - remove oldest messages when exceeding 50
        while (chatContainer.children.length > 50) {
          chatContainer.removeChild(chatContainer.children[0]);
        }
      };

      socket.onclose = () => {
        console.log('Disconnected');
        const chatList = document.getElementById('chat');
        chatList.innerHTML = '<li>Live ended</li>';
      };
    </script>
  </body>
</html>
